; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=gvn -S | FileCheck %s

define b8 @int_to_byte(ptr %p, i8 %val) {
; CHECK-LABEL: @int_to_byte(
; CHECK-NEXT:    store i8 [[VAL:%.*]], ptr [[P:%.*]], align 1
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 [[VAL]] to b8
; CHECK-NEXT:    ret b8 [[TMP1]]
;
  store i8 %val, ptr %p
  %y = load b8, ptr %p
  ret b8 %y
}

define b8 @int_trunc_to_byte(ptr %p, i16 %val) {
; CHECK-LABEL: @int_trunc_to_byte(
; CHECK-NEXT:    store i16 [[VAL:%.*]], ptr [[P:%.*]], align 2
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i16 [[VAL]] to b16
; CHECK-NEXT:    [[Y:%.*]] = trunc b16 [[TMP1]] to b8
; CHECK-NEXT:    ret b8 [[Y]]
;
  store i16 %val, ptr %p
  %y = load b8, ptr %p
  ret b8 %y
}

define b64 @ptr_to_byte(ptr %p) {
; CHECK-LABEL: @ptr_to_byte(
; CHECK-NEXT:    store ptr [[P:%.*]], ptr [[P]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast ptr [[P]] to b64
; CHECK-NEXT:    ret b64 [[TMP1]]
;
  store ptr %p, ptr %p
  %y = load b64, ptr %p
  ret b64 %y
}

; There is no sound way to convert a pointer to a byte of smaller width
define b8 @ptr_trunc_to_byte(ptr %p) {
; CHECK-LABEL: @ptr_trunc_to_byte(
; CHECK-NEXT:    store ptr [[P:%.*]], ptr [[P]], align 8
; CHECK-NEXT:    [[Y:%.*]] = load b8, ptr [[P]], align 1
; CHECK-NEXT:    ret b8 [[Y]]
;
  store ptr %p, ptr %p
  %y = load b8, ptr %p
  ret b8 %y
}

define b32 @float_to_byte(ptr %p, float %val) {
; CHECK-LABEL: @float_to_byte(
; CHECK-NEXT:    store float [[VAL:%.*]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast float [[VAL]] to b32
; CHECK-NEXT:    ret b32 [[TMP1]]
;
  store float %val, ptr %p
  %y = load b32, ptr %p
  ret b32 %y
}

define b8 @float_trunc_to_byte(ptr %p, float %val) {
; CHECK-LABEL: @float_trunc_to_byte(
; CHECK-NEXT:    store float [[VAL:%.*]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast float [[VAL]] to b32
; CHECK-NEXT:    [[TMP3:%.*]] = trunc b32 [[TMP1]] to b8
; CHECK-NEXT:    ret b8 [[TMP3]]
;
  store float %val, ptr %p
  %y = load b8, ptr %p
  ret b8 %y
}

define i8 @byte_to_int(ptr %p, b8 %val) {
; CHECK-LABEL: @byte_to_int(
; CHECK-NEXT:    store b8 [[VAL:%.*]], ptr [[P:%.*]], align 1
; CHECK-NEXT:    [[TMP1:%.*]] = bytecast exact b8 [[VAL]] to i8
; CHECK-NEXT:    ret i8 [[TMP1]]
;
  store b8 %val, ptr %p
  %y = load i8, ptr %p
  ret i8 %y
}

define i8 @byte_trunc_to_int(ptr %p, b16 %val) {
; CHECK-LABEL: @byte_trunc_to_int(
; CHECK-NEXT:    store b16 [[VAL:%.*]], ptr [[P:%.*]], align 2
; CHECK-NEXT:    [[TMP2:%.*]] = trunc b16 [[VAL]] to b8
; CHECK-NEXT:    [[TMP1:%.*]] = bytecast exact b8 [[TMP2]] to i8
; CHECK-NEXT:    ret i8 [[TMP1]]
;
  store b16 %val, ptr %p
  %y = load i8, ptr %p
  ret i8 %y
}

define ptr @byte_to_ptr(ptr %p, b64 %val) {
; CHECK-LABEL: @byte_to_ptr(
; CHECK-NEXT:    store b64 [[VAL:%.*]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = bytecast exact b64 [[VAL]] to ptr
; CHECK-NEXT:    ret ptr [[TMP1]]
;
  store b64 %val, ptr %p
  %y = load ptr, ptr %p
  ret ptr %y
}

define ptr @byte_trunc_to_ptr(ptr %p, b128 %val) {
; CHECK-LABEL: @byte_trunc_to_ptr(
; CHECK-NEXT:    store b128 [[VAL:%.*]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = trunc b128 [[VAL]] to b64
; CHECK-NEXT:    [[TMP1:%.*]] = bytecast exact b64 [[TMP2]] to ptr
; CHECK-NEXT:    ret ptr [[TMP1]]
;
  store b128 %val, ptr %p
  %y = load ptr, ptr %p
  ret ptr %y
}

define b64 @intptr_to_b64(ptr %p, i64 %val) {
; CHECK-LABEL: @intptr_to_b64(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sge i64 [[VAL:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[ADD:%.*]] = add i64 [[VAL]], 4
; CHECK-NEXT:    store i64 [[ADD]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i64 [[ADD]] to b64
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    store ptr [[P]], ptr [[P]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast ptr [[P]] to b64
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[Y:%.*]] = phi b64 [ [[TMP1]], [[BB2]] ], [ [[TMP0]], [[BB1]] ]
; CHECK-NEXT:    ret b64 [[Y]]
;
entry:
  %cmp = icmp sge i64 %val, 0
  br i1 %cmp, label %bb1, label %bb2

bb1:
  %add = add i64 %val, 4
  store i64 %add, ptr %p
  br label %merge

bb2:
  store ptr %p, ptr %p
  br label %merge

merge:
  %y = load b64, ptr %p
  ret b64 %y
}

define b8 @intptr_to_b8(ptr %p, i32 %val) {
; CHECK-LABEL: @intptr_to_b8(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sge i32 [[VAL:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[VAL]], 4
; CHECK-NEXT:    store i32 [[ADD]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 [[ADD]] to b32
; CHECK-NEXT:    [[TMP1:%.*]] = trunc b32 [[TMP0]] to b8
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    store ptr [[P]], ptr [[P]], align 8
; CHECK-NEXT:    [[TMP4:%.*]] = load b8, ptr [[P]], align 1
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[Y:%.*]] = phi b8 [ [[TMP4]], [[BB2]] ], [ [[TMP1]], [[BB1]] ]
; CHECK-NEXT:    ret b8 [[Y]]
;
entry:
  %cmp = icmp sge i32 %val, 0
  br i1 %cmp, label %bb1, label %bb2

bb1:
  %add = add i32 %val, 4
  store i32 %add, ptr %p
  br label %merge

bb2:
  store ptr %p, ptr %p
  br label %merge

merge:
  %y = load b8, ptr %p
  ret b8 %y
}

define i64 @byteptr_to_i64(ptr %p, i64 %val, b64 %add) {
; CHECK-LABEL: @byteptr_to_i64(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sge i64 [[VAL:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    store b64 [[ADD:%.*]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = bytecast exact b64 [[ADD]] to i64
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    store ptr [[P]], ptr [[P]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[P]] to i64
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[Y:%.*]] = phi i64 [ [[TMP1]], [[BB2]] ], [ [[TMP0]], [[BB1]] ]
; CHECK-NEXT:    ret i64 [[Y]]
;
entry:
  %cmp = icmp sge i64 %val, 0
  br i1 %cmp, label %bb1, label %bb2

bb1:
  store b64 %add, ptr %p
  br label %merge

bb2:
  store ptr %p, ptr %p
  br label %merge

merge:
  %y = load i64, ptr %p
  ret i64 %y
}

define i32 @byteptr_to_i32(ptr %p, i32 %val, b64 %add) {
; CHECK-LABEL: @byteptr_to_i32(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sge i32 [[VAL:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    store b64 [[ADD:%.*]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = trunc b64 [[ADD]] to b32
; CHECK-NEXT:    [[Y_PRE:%.*]] = bytecast exact b32 [[TMP2]] to i32
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    store ptr [[P]], ptr [[P]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[P]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = trunc i64 [[TMP0]] to i32
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[Y:%.*]] = phi i32 [ [[TMP1]], [[BB2]] ], [ [[Y_PRE]], [[BB1]] ]
; CHECK-NEXT:    ret i32 [[Y]]
;
entry:
  %cmp = icmp sge i32 %val, 0
  br i1 %cmp, label %bb1, label %bb2

bb1:
  store b64 %add, ptr %p
  br label %merge

bb2:
  store ptr %p, ptr %p
  br label %merge

merge:
  %y = load i32, ptr %p
  ret i32 %y
}

; There is no way of converting a byte to a smaller byte
define b8 @byte_to_smaller_byte(ptr %p, b16 %val) {
; CHECK-LABEL: @byte_to_smaller_byte(
; CHECK-NEXT:    store b16 [[VAL:%.*]], ptr [[P:%.*]], align 2
; CHECK-NEXT:    [[Y:%.*]] = load b8, ptr [[P]], align 1
; CHECK-NEXT:    ret b8 [[Y]]
;
  store b16 %val, ptr %p
  %y = load b8, ptr %p
  ret b8 %y
}

define i32 @crash() {
; CHECK-LABEL: @crash(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr inttoptr (i64 2 to ptr), align 1
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 [[TMP0]] to b8
; CHECK-NEXT:    switch i8 [[TMP0]], label [[IF_END80:%.*]] [
; CHECK-NEXT:      i8 0, label [[IF_THEN78:%.*]]
; CHECK-NEXT:      i8 1, label [[IF_THEN78]]
; CHECK-NEXT:    ]
; CHECK:       if.then78:
; CHECK-NEXT:    [[DOTPRE:%.*]] = load b8, ptr null, align 1
; CHECK-NEXT:    br label [[IF_END80]]
; CHECK:       if.end80:
; CHECK-NEXT:    [[TMP2:%.*]] = phi b8 [ [[DOTPRE]], [[IF_THEN78]] ], [ [[TMP1]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[S_2:%.*]] = phi ptr [ null, [[IF_THEN78]] ], [ inttoptr (i64 2 to ptr), [[ENTRY]] ]
; CHECK-NEXT:    [[CONV82:%.*]] = bytecast b8 [[TMP2]] to i8
; CHECK-NEXT:    ret i32 0
;
entry:
  %0 = load i8, ptr inttoptr (i64 2 to ptr), align 1
  switch i8 %0, label %if.end80 [
  i8 0, label %if.then78
  i8 1, label %if.then78
  ]

if.then78:
  br label %if.end80

if.end80:
  %s.2 = phi ptr [ null, %if.then78 ], [ inttoptr (i64 2 to ptr), %entry ]
  %1 = load b8, ptr %s.2, align 1
  %conv82 = bytecast b8 %1 to i8
  ret i32 0
}
