; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=gvn -S | FileCheck %s

declare void @use(...) readonly

define ptr @i64-ptr-use-ptr(ptr %p, i1 %cond) {
; CHECK-LABEL: @i64-ptr-use-ptr(
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP1:%.*]] = load b64, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = bytecast exact b64 [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = bytecast exact b64 [[TMP1]] to ptr
; CHECK-NEXT:    call void @use(i64 [[TMP2]])
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[V2:%.*]] = load ptr, ptr [[P]], align 8
; CHECK-NEXT:    call void @use(ptr [[V2]])
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[V3:%.*]] = phi ptr [ [[V2]], [[BB2]] ], [ [[TMP3]], [[BB1]] ]
; CHECK-NEXT:    ret ptr [[V3]]
;
  br i1 %cond, label %bb1, label %bb2

bb1:
  %v1 = load i64, ptr %p
  call void @use(i64 %v1)
  br label %merge

bb2:
  %v2 = load ptr, ptr %p
  call void @use(ptr %v2)
  br label %merge

merge:
  %v3 = load ptr, ptr %p
  ret ptr %v3
}

define ptr @i64-ptr-use-both(ptr %p, i1 %cond) {
; CHECK-LABEL: @i64-ptr-use-both(
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP1:%.*]] = load b64, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = bytecast exact b64 [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = bytecast exact b64 [[TMP1]] to ptr
; CHECK-NEXT:    call void @use(i64 [[TMP2]])
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[TMP4:%.*]] = load b64, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = bytecast exact b64 [[TMP4]] to ptr
; CHECK-NEXT:    [[TMP6:%.*]] = bytecast exact b64 [[TMP4]] to i64
; CHECK-NEXT:    call void @use(ptr [[TMP5]])
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[V3:%.*]] = phi ptr [ [[TMP5]], [[BB2]] ], [ [[TMP3]], [[BB1]] ]
; CHECK-NEXT:    [[TMP7:%.*]] = phi i64 [ [[TMP6]], [[BB2]] ], [ [[TMP2]], [[BB1]] ]
; CHECK-NEXT:    call void @use(i64 [[TMP7]])
; CHECK-NEXT:    ret ptr [[V3]]
;
  br i1 %cond, label %bb1, label %bb2

bb1:
  %v1 = load i64, ptr %p
  call void @use(i64 %v1)
  br label %merge

bb2:
  %v2 = load ptr, ptr %p
  call void @use(ptr %v2)
  br label %merge

merge:
  %2 = load i64, ptr %p
  call void @use(i64 %2)
  %v3 = load ptr, ptr %p
  ret ptr %v3
}

define ptr @double-ptr-use-both(ptr %p, i1 %cond) {
; CHECK-LABEL: @double-ptr-use-both(
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP1:%.*]] = load b64, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = bytecast exact b64 [[TMP1]] to double
; CHECK-NEXT:    [[TMP3:%.*]] = bytecast exact b64 [[TMP1]] to ptr
; CHECK-NEXT:    call void @use(double [[TMP2]])
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[TMP4:%.*]] = load b64, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = bytecast exact b64 [[TMP4]] to ptr
; CHECK-NEXT:    [[TMP6:%.*]] = bytecast exact b64 [[TMP4]] to double
; CHECK-NEXT:    call void @use(ptr [[TMP5]])
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[V3:%.*]] = phi ptr [ [[TMP5]], [[BB2]] ], [ [[TMP3]], [[BB1]] ]
; CHECK-NEXT:    [[TMP7:%.*]] = phi double [ [[TMP6]], [[BB2]] ], [ [[TMP2]], [[BB1]] ]
; CHECK-NEXT:    call void @use(double [[TMP7]])
; CHECK-NEXT:    ret ptr [[V3]]
;
  br i1 %cond, label %bb1, label %bb2

bb1:
  %v1 = load double, ptr %p
  call void @use(double %v1)
  br label %merge

bb2:
  %v2 = load ptr, ptr %p
  call void @use(ptr %v2)
  br label %merge

merge:
  %2 = load double, ptr %p
  call void @use(double %2)
  %v3 = load ptr, ptr %p
  ret ptr %v3
}

define ptr @_2i32-ptr-use-both(ptr %p, i1 %cond) {
; CHECK-LABEL: @_2i32-ptr-use-both(
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP1:%.*]] = load b64, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = bytecast exact b64 [[TMP1]] to <2 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = bytecast exact b64 [[TMP1]] to ptr
; CHECK-NEXT:    call void @use(<2 x i32> [[TMP3]])
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[TMP5:%.*]] = load b64, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = bytecast exact b64 [[TMP5]] to ptr
; CHECK-NEXT:    [[TMP8:%.*]] = bytecast exact b64 [[TMP5]] to <2 x i32>
; CHECK-NEXT:    call void @use(ptr [[TMP7]])
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[V3:%.*]] = phi ptr [ [[TMP7]], [[BB2]] ], [ [[TMP4]], [[BB1]] ]
; CHECK-NEXT:    [[TMP9:%.*]] = phi <2 x i32> [ [[TMP8]], [[BB2]] ], [ [[TMP3]], [[BB1]] ]
; CHECK-NEXT:    call void @use(<2 x i32> [[TMP9]])
; CHECK-NEXT:    ret ptr [[V3]]
;
  br i1 %cond, label %bb1, label %bb2

bb1:
  %v1 = load <2 x i32>, ptr %p
  call void @use(<2 x i32> %v1)
  br label %merge

bb2:
  %v2 = load ptr, ptr %p
  call void @use(ptr %v2)
  br label %merge

merge:
  %2 = load <2 x i32>, ptr %p
  call void @use(<2 x i32> %2)
  %v3 = load ptr, ptr %p
  ret ptr %v3
}

define <2 x ptr> @i64-2ptr-use-both(ptr %p, i1 %cond) {
; CHECK-LABEL: @i64-2ptr-use-both(
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[V1:%.*]] = load i64, ptr [[P:%.*]], align 4
; CHECK-NEXT:    call void @use(i64 [[V1]])
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[TMP1:%.*]] = load b128, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = trunc b128 [[TMP1]] to b64
; CHECK-NEXT:    [[TMP3:%.*]] = bytecast exact b128 [[TMP1]] to <2 x ptr>
; CHECK-NEXT:    [[TMP4:%.*]] = bytecast exact b64 [[TMP2]] to i64
; CHECK-NEXT:    call void @use(<2 x ptr> [[TMP3]])
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[TMP5:%.*]] = phi i64 [ [[TMP4]], [[BB2]] ], [ [[V1]], [[BB1]] ]
; CHECK-NEXT:    call void @use(i64 [[TMP5]])
; CHECK-NEXT:    [[V3:%.*]] = load <2 x ptr>, ptr [[P]], align 16
; CHECK-NEXT:    ret <2 x ptr> [[V3]]
;
  br i1 %cond, label %bb1, label %bb2

bb1:
  %v1 = load i64, ptr %p
  call void @use(i64 %v1)
  br label %merge

bb2:
  %v2 = load <2 x ptr>, ptr %p
  call void @use(<2 x ptr> %v2)
  br label %merge

merge:
  %2 = load i64, ptr %p
  call void @use(i64 %2)
  %v3 = load <2 x ptr>, ptr %p
  ret <2 x ptr> %v3
}

define ptr @_2double-ptr-use-both(ptr %p, i1 %cond) {
; CHECK-LABEL: @_2double-ptr-use-both(
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP1:%.*]] = load b128, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = trunc b128 [[TMP1]] to b64
; CHECK-NEXT:    [[TMP3:%.*]] = bytecast exact b128 [[TMP1]] to <2 x double>
; CHECK-NEXT:    [[TMP4:%.*]] = bytecast exact b64 [[TMP2]] to ptr
; CHECK-NEXT:    call void @use(<2 x double> [[TMP3]])
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[V2:%.*]] = load ptr, ptr [[P]], align 8
; CHECK-NEXT:    call void @use(ptr [[V2]])
; CHECK-NEXT:    [[TMP5:%.*]] = load b128, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = trunc b128 [[TMP5]] to b64
; CHECK-NEXT:    [[TMP7:%.*]] = bytecast exact b128 [[TMP5]] to <2 x double>
; CHECK-NEXT:    [[TMP8:%.*]] = bytecast exact b64 [[TMP6]] to ptr
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[V3:%.*]] = phi ptr [ [[TMP8]], [[BB2]] ], [ [[TMP4]], [[BB1]] ]
; CHECK-NEXT:    [[TMP9:%.*]] = phi <2 x double> [ [[TMP7]], [[BB2]] ], [ [[TMP3]], [[BB1]] ]
; CHECK-NEXT:    call void @use(<2 x double> [[TMP9]])
; CHECK-NEXT:    ret ptr [[V3]]
;
  br i1 %cond, label %bb1, label %bb2

bb1:
  %v1 = load <2 x double>, ptr %p
  call void @use(<2 x double> %v1)
  br label %merge

bb2:
  %v2 = load ptr, ptr %p
  call void @use(ptr %v2)
  br label %merge

merge:
  %2 = load <2 x double>, ptr %p
  call void @use(<2 x double> %2)
  %v3 = load ptr, ptr %p
  ret ptr %v3
}

define ptr @_2i8-ptr-use-both(ptr %p, i1 %cond) {
; CHECK-LABEL: @_2i8-ptr-use-both(
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[V1:%.*]] = load <2 x i8>, ptr [[P:%.*]], align 2
; CHECK-NEXT:    call void @use(<2 x i8> [[V1]])
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[TMP1:%.*]] = load b64, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = trunc b64 [[TMP1]] to b16
; CHECK-NEXT:    [[TMP3:%.*]] = bytecast exact b64 [[TMP1]] to ptr
; CHECK-NEXT:    [[TMP4:%.*]] = bytecast exact b16 [[TMP2]] to <2 x i8>
; CHECK-NEXT:    call void @use(ptr [[TMP3]])
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[TMP5:%.*]] = phi <2 x i8> [ [[TMP4]], [[BB2]] ], [ [[V1]], [[BB1]] ]
; CHECK-NEXT:    call void @use(<2 x i8> [[TMP5]])
; CHECK-NEXT:    [[V3:%.*]] = load ptr, ptr [[P]], align 8
; CHECK-NEXT:    ret ptr [[V3]]
;
  br i1 %cond, label %bb1, label %bb2

bb1:
  %v1 = load <2 x i8>, ptr %p
  call void @use(<2 x i8> %v1)
  br label %merge

bb2:
  %v2 = load ptr, ptr %p
  call void @use(ptr %v2)
  br label %merge

merge:
  %2 = load <2 x i8>, ptr %p
  call void @use(<2 x i8> %2)
  %v3 = load ptr, ptr %p
  ret ptr %v3
}

define <2 x ptr> @_2i8-2ptr-use-both(ptr %p, i1 %cond) {
; CHECK-LABEL: @_2i8-2ptr-use-both(
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[V1:%.*]] = load <2 x i8>, ptr [[P:%.*]], align 2
; CHECK-NEXT:    call void @use(<2 x i8> [[V1]])
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[TMP1:%.*]] = load b128, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = trunc b128 [[TMP1]] to b16
; CHECK-NEXT:    [[TMP3:%.*]] = bytecast exact b128 [[TMP1]] to <2 x ptr>
; CHECK-NEXT:    [[TMP4:%.*]] = bytecast exact b16 [[TMP2]] to <2 x i8>
; CHECK-NEXT:    call void @use(<2 x ptr> [[TMP3]])
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[TMP5:%.*]] = phi <2 x i8> [ [[TMP4]], [[BB2]] ], [ [[V1]], [[BB1]] ]
; CHECK-NEXT:    call void @use(<2 x i8> [[TMP5]])
; CHECK-NEXT:    [[V3:%.*]] = load <2 x ptr>, ptr [[P]], align 16
; CHECK-NEXT:    ret <2 x ptr> [[V3]]
;
  br i1 %cond, label %bb1, label %bb2

bb1:
  %v1 = load <2 x i8>, ptr %p
  call void @use(<2 x i8> %v1)
  br label %merge

bb2:
  %v2 = load <2 x ptr>, ptr %p
  call void @use(<2 x ptr> %v2)
  br label %merge

merge:
  %2 = load <2 x i8>, ptr %p
  call void @use(<2 x i8> %2)
  %v3 = load <2 x ptr>, ptr %p
  ret <2 x ptr> %v3
}

define ptr @b64-ptr-use-b64-ptr(ptr %p, i1 %cond) {
; CHECK-LABEL: @b64-ptr-use-b64-ptr(
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP3:%.*]] = load b64, ptr [[P:%.*]], align 4
; CHECK-NEXT:    call void @use(b64 [[TMP3]])
; CHECK-NEXT:    [[TMP1:%.*]] = bytecast exact b64 [[TMP3]] to ptr
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[TMP2:%.*]] = load b64, ptr [[P]], align 4
; CHECK-NEXT:    [[V2:%.*]] = bytecast exact b64 [[TMP2]] to ptr
; CHECK-NEXT:    call void @use(ptr [[V2]])
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[V3:%.*]] = phi ptr [ [[V2]], [[BB2]] ], [ [[TMP1]], [[BB1]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = phi b64 [ [[TMP2]], [[BB2]] ], [ [[TMP3]], [[BB1]] ]
; CHECK-NEXT:    call void @use(b64 [[TMP4]])
; CHECK-NEXT:    ret ptr [[V3]]
;
  br i1 %cond, label %bb1, label %bb2

bb1:
  %v1 = load b64, ptr %p
  call void @use(b64 %v1)
  br label %merge

bb2:
  %v2 = load ptr, ptr %p
  call void @use(ptr %v2)
  br label %merge

merge:
  %2 = load b64, ptr %p
  call void @use(b64 %2)
  %v3 = load ptr, ptr %p
  ret ptr %v3
}

; It is not sound to trunc the i64, as it may be poison.
define i32 @load-i64-i32(ptr %p) {
; CHECK-LABEL: @load-i64-i32(
; CHECK-NEXT:    [[TMP1:%.*]] = load b64, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = trunc b64 [[TMP1]] to b32
; CHECK-NEXT:    [[TMP2:%.*]] = bytecast exact b64 [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = bytecast exact b32 [[TMP4]] to i32
; CHECK-NEXT:    call void @use(i64 [[TMP2]])
; CHECK-NEXT:    ret i32 [[TMP3]]
;
  %l1 = load i64, ptr %p
  call void @use(i64 %l1)
  %l2 = load i32, ptr %p
  ret i32 %l2
}

; It is not sound to trunc the double, as it may be poison.
define float @load-double-float(ptr %p) {
; CHECK-LABEL: @load-double-float(
; CHECK-NEXT:    [[TMP1:%.*]] = load b64, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = trunc b64 [[TMP1]] to b32
; CHECK-NEXT:    [[TMP2:%.*]] = bytecast exact b64 [[TMP1]] to double
; CHECK-NEXT:    [[TMP3:%.*]] = bytecast exact b32 [[TMP4]] to float
; CHECK-NEXT:    call void @use(double [[TMP2]])
; CHECK-NEXT:    ret float [[TMP3]]
;
  %l1 = load double, ptr %p
  call void @use(double %l1)
  %l2 = load float, ptr %p
  ret float %l2
}
