; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -O1 < %s | FileCheck %s
; RUN: opt -S -O2 < %s | FileCheck %s
; RUN: opt -S -O3 < %s | FileCheck %s

define void @swap(ptr %p1, ptr %p2) {
; CHECK-LABEL: @swap(
; CHECK-NEXT:    [[TMP1:%.*]] = load b64, ptr [[P1:%.*]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = load b64, ptr [[P2:%.*]], align 1
; CHECK-NEXT:    store b64 [[TMP2]], ptr [[P1]], align 1
; CHECK-NEXT:    store b64 [[TMP1]], ptr [[P2]], align 1
; CHECK-NEXT:    ret void
;
  %tmp = alloca [2 x i32]
  call void @llvm.memcpy.p0.p0.i64(ptr %tmp, ptr %p1, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr %p1, ptr %p2, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr %p2, ptr %tmp, i64 8, i1 false)
  ret void
}

define i32 @test(i32 %n) {
; CHECK-LABEL: @test(
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[P1_SROA_0_1:%.*]] = phi b64 [ 4294967296, [[TMP0:%.*]] ], [ [[TMP5:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[P1_SROA_0_0_EXTRACT_TRUNC:%.*]] = trunc b64 [[P1_SROA_0_1]] to b32
; CHECK-NEXT:    [[P1_SROA_0_0:%.*]] = bytecast exact b32 [[P1_SROA_0_0_EXTRACT_TRUNC]] to i32
; CHECK-NEXT:    [[V1_INC:%.*]] = add i32 [[P1_SROA_0_0]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = bytecast exact b64 [[P1_SROA_0_1]] to i64
; CHECK-NEXT:    [[P1_SROA_0_0_INSERT_EXT:%.*]] = zext i32 [[V1_INC]] to i64
; CHECK-NEXT:    [[P1_SROA_0_0_INSERT_MASK2:%.*]] = and i64 [[TMP2]], -4294967296
; CHECK-NEXT:    [[P1_SROA_0_0_INSERT_INSERT3:%.*]] = or disjoint i64 [[P1_SROA_0_0_INSERT_MASK2]], [[P1_SROA_0_0_INSERT_EXT]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i64 [[P1_SROA_0_0_INSERT_INSERT3]] to b64
; CHECK-NEXT:    [[P1_SROA_0_4_EXTRACT_SHIFT:%.*]] = lshr b64 [[TMP3]], 32
; CHECK-NEXT:    [[P1_SROA_0_4_EXTRACT_TRUNC:%.*]] = trunc b64 [[P1_SROA_0_4_EXTRACT_SHIFT]] to b32
; CHECK-NEXT:    [[P1_SROA_5_0:%.*]] = bytecast exact b32 [[P1_SROA_0_4_EXTRACT_TRUNC]] to i32
; CHECK-NEXT:    [[V2_NEXT:%.*]] = shl i32 [[P1_SROA_5_0]], 1
; CHECK-NEXT:    [[P1_SROA_0_4_INSERT_EXT:%.*]] = zext i32 [[V2_NEXT]] to i64
; CHECK-NEXT:    [[P1_SROA_0_4_INSERT_SHIFT:%.*]] = shl nuw i64 [[P1_SROA_0_4_INSERT_EXT]], 32
; CHECK-NEXT:    [[P1_SROA_0_4_INSERT_INSERT6:%.*]] = or disjoint i64 [[P1_SROA_0_4_INSERT_SHIFT]], [[P1_SROA_0_0_INSERT_EXT]]
; CHECK-NEXT:    [[TMP5]] = bitcast i64 [[P1_SROA_0_4_INSERT_INSERT6]] to b64
; CHECK-NEXT:    [[C:%.*]] = icmp eq i32 [[V1_INC]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[C]], label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    [[P2_SROA_0_4_EXTRACT_SHIFT:%.*]] = lshr b64 [[TMP5]], 32
; CHECK-NEXT:    [[P2_SROA_0_4_EXTRACT_TRUNC:%.*]] = trunc b64 [[P2_SROA_0_4_EXTRACT_SHIFT]] to b32
; CHECK-NEXT:    [[TMP6:%.*]] = bytecast exact b32 [[P2_SROA_0_4_EXTRACT_TRUNC]] to i32
; CHECK-NEXT:    ret i32 [[TMP6]]
;
  %p1 = alloca [2 x i32]
  %p2 = alloca [2 x i32]
  %p1.2 = getelementptr i32, ptr %p1, i64 1
  %p2.2 = getelementptr i32, ptr %p2, i64 1
  store i32 0, ptr %p1
  store i32 1, ptr %p1.2
  br label %loop

loop:
  %v1 = load i32, ptr %p1
  %v1.inc = add i32 %v1, 1
  store i32 %v1.inc, ptr %p1
  %v2 = load i32, ptr %p1.2
  %v2.next = shl i32 %v2, 1
  store i32 %v2.next, ptr %p1.2
  %c = icmp eq i32 %v1.inc, %n
  br i1 %c, label %exit, label %loop

exit:
  call void @swap(ptr %p1, ptr %p2)
  %res = load i32, ptr %p2.2
  ret i32 %res
}

declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)
