; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=sroa -S | FileCheck %s

define i8 @bytetoint(b8 %x) {
; CHECK-LABEL: @bytetoint(
; CHECK-NEXT:    [[TMP1:%.*]] = bytecast exact b8 [[X:%.*]] to i8
; CHECK-NEXT:    ret i8 [[TMP1]]
;
  %a = alloca b8
  store b8 %x, ptr %a
  %v = load i8, ptr %a
  ret i8 %v
}

define ptr @bytetoptr(b64 %x) {
; CHECK-LABEL: @bytetoptr(
; CHECK-NEXT:    [[TMP1:%.*]] = bytecast exact b64 [[X:%.*]] to ptr
; CHECK-NEXT:    ret ptr [[TMP1]]
;
  %a = alloca b64
  store b64 %x, ptr %a
  %v = load ptr, ptr %a
  ret ptr %v
}

define float @bytetofloat(b32 %x) {
; CHECK-LABEL: @bytetofloat(
; CHECK-NEXT:    [[TMP1:%.*]] = bytecast exact b32 [[X:%.*]] to float
; CHECK-NEXT:    ret float [[TMP1]]
;
  %a = alloca b32
  store b32 %x, ptr %a
  %v = load float, ptr %a
  ret float %v
}

define i8 @trunc_bytetoint(b32 %x) {
; CHECK-LABEL: @trunc_bytetoint(
; CHECK-NEXT:    [[A_0_EXTRACT_TRUNC:%.*]] = trunc b32 [[X:%.*]] to b8
; CHECK-NEXT:    [[TMP1:%.*]] = bytecast exact b8 [[A_0_EXTRACT_TRUNC]] to i8
; CHECK-NEXT:    ret i8 [[TMP1]]
;
  %a = alloca b32
  store b32 %x, ptr %a
  %v = load i8, ptr %a
  ret i8 %v
}

define i8 @trunc_bytetoint_offset(b32 %x) {
; CHECK-LABEL: @trunc_bytetoint_offset(
; CHECK-NEXT:    [[A_2_EXTRACT_SHIFT:%.*]] = lshr b32 [[X:%.*]], 16
; CHECK-NEXT:    [[A_2_EXTRACT_TRUNC:%.*]] = trunc b32 [[A_2_EXTRACT_SHIFT]] to b8
; CHECK-NEXT:    [[TMP1:%.*]] = bytecast exact b8 [[A_2_EXTRACT_TRUNC]] to i8
; CHECK-NEXT:    ret i8 [[TMP1]]
;
  %a = alloca b32
  %gep = getelementptr i8, ptr %a, i32 2
  store b32 %x, ptr %a
  %v = load i8, ptr %gep
  ret i8 %v
}

define b8 @inttobyte(i8 %x) {
; CHECK-LABEL: @inttobyte(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 [[X:%.*]] to b8
; CHECK-NEXT:    ret b8 [[TMP1]]
;
  %a = alloca i8
  store i8 %x, ptr %a
  %v = load b8, ptr %a
  ret b8 %v
}

define b64 @ptrtobyte(ptr %x) {
; CHECK-LABEL: @ptrtobyte(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast ptr [[X:%.*]] to b64
; CHECK-NEXT:    ret b64 [[TMP1]]
;
  %a = alloca ptr
  store ptr %x, ptr %a
  %v = load b64, ptr %a
  ret b64 %v
}

define b32 @floattobyte(float %x) {
; CHECK-LABEL: @floattobyte(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast float [[X:%.*]] to b32
; CHECK-NEXT:    ret b32 [[TMP1]]
;
  %a = alloca float
  store float %x, ptr %a
  %v = load b32, ptr %a
  ret b32 %v
}

define <2 x ptr> @scalartovector_bytetoptr(b128 %x) {
; CHECK-LABEL: @scalartovector_bytetoptr(
; CHECK-NEXT:    [[TMP2:%.*]] = bytecast exact b128 [[X:%.*]] to <2 x ptr>
; CHECK-NEXT:    ret <2 x ptr> [[TMP2]]
;
  %a = alloca b128, align 16
  store b128 %x, ptr %a, align 16
  %v = load <2 x ptr>, ptr %a
  ret <2 x ptr> %v
}

define <4 x i16> @scalartovector_bytetoint(b64 %x) {
; CHECK-LABEL: @scalartovector_bytetoint(
; CHECK-NEXT:    [[TMP2:%.*]] = bytecast exact b64 [[X:%.*]] to <4 x i16>
; CHECK-NEXT:    ret <4 x i16> [[TMP2]]
;
  %a = alloca b64
  store b64 %x, ptr %a
  %v = load <4 x i16>, ptr %a
  ret <4 x i16> %v
}

define <2 x float> @scalartovector_bytetofloat(b64 %x) {
; CHECK-LABEL: @scalartovector_bytetofloat(
; CHECK-NEXT:    [[TMP2:%.*]] = bytecast exact b64 [[X:%.*]] to <2 x float>
; CHECK-NEXT:    ret <2 x float> [[TMP2]]
;
  %a = alloca b64
  store b64 %x, ptr %a
  %v = load <2 x float>, ptr %a
  ret <2 x float> %v
}

define <4 x b8> @vectortoscalar_inttobyte(i32 %x) {
; CHECK-LABEL: @vectortoscalar_inttobyte(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 [[X:%.*]] to <4 x b8>
; CHECK-NEXT:    ret <4 x b8> [[TMP1]]
;
  %a = alloca i32
  store i32 %x, ptr %a
  %v = load <4 x b8>, ptr %a
  ret <4 x b8> %v
}

define i8 @byte(b8 %x) {
; CHECK-LABEL: @byte(
; CHECK-NEXT:    [[TMP1:%.*]] = bytecast exact b8 [[X:%.*]] to i8
; CHECK-NEXT:    ret i8 [[TMP1]]
;
  %a = alloca b8
  store b8 %x, ptr %a
  %v = load i8, ptr %a
  ret i8 %v
}
